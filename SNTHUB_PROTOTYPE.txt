local success, WindUI = pcall(function()
    return loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()
end)

if not success then
    game:GetService("StarterGui"):SetCore("SendNotification",{
        Title = "Ошибка",
        Text = "Не удалось загрузить библиотеку UI",
        Duration = 5
    })
    return
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Настройки настроек?

local Settings = {
    Hitbox = {
        Enabled = false,
        Size = 5,
        Color = Color3.new(1,0,0),
        Adornments = {},
        Connections = {}
    },
    Noclip = {
        Enabled = false,
        Connection = nil
    },
    AntiAFK = {
        Enabled = false,
        Connection = nil
    }
}

-- Настройки персонажа
local CharacterSettings = {
    WalkSpeed = {
        Value = 16,
        Default = 16,
        Locked = false
    },
    JumpPower = {
        Value = 50,
        Default = 50,
        Locked = false
    }
}

-- Создание окна

local Window = WindUI:CreateWindow({
    Title = "SNT HUB | ESP&AIMBOT",
    Size = UDim2.fromOffset(350,350),
    Theme = "Dark",
    Transparent = true,
    HasOutline = true
})

local function SafeCall(fn)
    local s, err = pcall(fn)
    if not s then warn("Ошибка:", err) end
end

-- Ноклип
local function ToggleNoclip(state)
    SafeCall(function()
        if state then
            Settings.Noclip.Connection = RunService.Stepped:Connect(function()
                local chr = LocalPlayer.Character
                if chr then
                    for _, part in pairs(chr:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if Settings.Noclip.Connection then
                Settings.Noclip.Connection:Disconnect()
            end
        end
    end)
end

-- Хитбоксы
local function UpdateHitboxes()
    SafeCall(function()
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                local chr = plr.Character
                local box = Settings.Hitbox.Adornments[plr]
                
                if chr and Settings.Hitbox.Enabled then
                    local root = chr:FindFirstChild("HumanoidRootPart")
                    if root then
                        if not box then
                            box = Instance.new("BoxHandleAdornment")
                            box.Adornee = root
                            box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)
                            box.Color3 = Settings.Hitbox.Color
                            box.Transparency = 0.4
                            box.ZIndex = 10
                            box.Parent = root
                            Settings.Hitbox.Adornments[plr] = box
                        else
                            box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)
                            box.Color3 = Settings.Hitbox.Color
                        end
                    end
                elseif box then
                    box:Destroy()
                    Settings.Hitbox.Adornments[plr] = nil
                end
            end
        end
    end)
end

-- Анти-AFK
local function ToggleAntiAFK(state)
    SafeCall(function()
        if state then
            Settings.AntiAFK.Connection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    local vu = game:GetService("VirtualUser")
                    vu:CaptureController()
                    vu:ClickButton2(Vector2.new())
                end)
            end)
        else
            if Settings.AntiAFK.Connection then
                Settings.AntiAFK.Connection:Disconnect()
            end
        end
    end)
end

local CharacterTab = Window:Tab({
    Title = "Персонаж",
    Icon = "user",
    Desc = "Управление характеристиками персонажа"
})

-- Функция обновления характеристик
local function updateCharacter()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        pcall(function()
            if not CharacterSettings.WalkSpeed.Locked then
                humanoid.WalkSpeed = CharacterSettings.WalkSpeed.Value
            end
            if not CharacterSettings.JumpPower.Locked then
                humanoid.JumpPower = CharacterSettings.JumpPower.Value
            end
        end)
    end
end

-- Автоматическое обновление при смене персонажа
LocalPlayer.CharacterAdded:Connect(function()
    updateCharacter()
    CharacterTab:Notify({
        Title = "Персонаж загружен",
        Text = "Настройки применены",
        Duration = 2
    })
end)

-- Элементы управления WalkSpeed
CharacterTab:Slider({
    Title = "Скорость передвижения",
    Value = {Min = 0, Max = 200, Default = 16},
    Callback = function(value)
        CharacterSettings.WalkSpeed.Value = value
        updateCharacter()
    end
})

CharacterTab:Button({
    Title = "Сброс скорости",
    Callback = function()
        CharacterSettings.WalkSpeed.Value = CharacterSettings.WalkSpeed.Default
        updateCharacter()
    end
})

CharacterTab:Toggle({
    Title = "Фиксировать скорость",
    Default = false,
    Callback = function(state)
        CharacterSettings.WalkSpeed.Locked = state
        if state then
            updateCharacter()
        end
    end
})

-- Элементы управления JumpPower
CharacterTab:Slider({
    Title = "Сила прыжка",
    Value = {Min = 0, Max = 200, Default = 50},
    Callback = function(value)
        CharacterSettings.JumpPower.Value = value
        updateCharacter()
    end
})

CharacterTab:Button({
    Title = "Сброс прыжка",
    Callback = function()
        CharacterSettings.JumpPower.Value = CharacterSettings.JumpPower.Default
        updateCharacter()
    end
})

CharacterTab:Toggle({
    Title = "Фиксировать прыжок",
    Default = false,
    Callback = function(state)
        CharacterSettings.JumpPower.Locked = state
        if state then
            updateCharacter()
        end
    end
})

-- Дополнительные функции
CharacterTab:Button({
    Title = "Респавн персонажа",
    Callback = function()
        local character = LocalPlayer.Character
        if character then
            character:BreakJoints()
        end
    end
})

-- Постоянное обновление
RunService.Heartbeat:Connect(function()
    if CharacterSettings.WalkSpeed.Locked or CharacterSettings.JumpPower.Locked then
        updateCharacter()
    end
end)

-- Первоначальная настройка
if LocalPlayer.Character then
    updateCharacter()
end

EspTab = Window:Tab({ Title = "ESP", Icon = "eye", Desc = "Подсветка игроков." })

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera
local runService = game:GetService("RunService")

local playerText = {}

local espSettings = {
    namesEnabled = false,
    distanceEnabled = false,
    namesColor = Color3.new(1, 1, 1),
    distanceColor = Color3.new(1, 1, 1),
}

local highlightEspSettings = {
    enabled = false,
    color = Color3.fromRGB(255, 0, 0),
    transparency = 0.5,
}

local colorOptions = {
    "White", "Red", "Blue", "Green", "Yellow"
}

local colorValues = {
    White = Color3.new(1, 1, 1),
    Red = Color3.new(1, 0, 0),
    Blue = Color3.new(0, 0, 1),
    Green = Color3.new(0, 1, 0),
    Yellow = Color3.new(1, 1, 0)
}

local function isAlive(player)
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        return character:FindFirstChild("Humanoid").Health > 0
    end
    return false
end

local function getDistance(player)
    if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and
       player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        return (localPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
    else
        return nil
    end
end

local function createText()
    local text = Drawing.new("Text")
    text.Size = 18
    text.Outline = true
    text.Center = true
    text.Visible = false
    return text
end

local function updateESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            -- Создаем/получаем текстовый объект для игрока
            if not playerText[player] then
                playerText[player] = createText()
            end
            
            local text = playerText[player]
            local character = player.Character
            text.Visible = false -- По умолчанию скрываем
            
            -- Проверяем, нужно ли вообще отображать ESP
            if (espSettings.namesEnabled or espSettings.distanceEnabled) and character then
                local head = character:FindFirstChild("Head")
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                
                if head and humanoidRootPart then
                    local screenPos, onScreen = camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1.5, 0))
                    
                    if onScreen then
                        -- Формируем текст в зависимости от настроек
                        local displayText = ""
                        local color = espSettings.namesColor
                        
                        if espSettings.namesEnabled then
                            displayText = player.Name
                        end
                        
                        if espSettings.distanceEnabled then
                            local distance = getDistance(player)
                            if distance then
                                if displayText ~= "" then
                                    displayText = displayText .. " "
                                end
                                displayText = displayText .. "["..math.floor(distance).." studs]"
                                color = espSettings.distanceColor
                            end
                        end
                        
                        -- Устанавливаем параметры текста
                        if displayText ~= "" then
                            text.Text = displayText
                            text.Color = color
                            text.Position = Vector2.new(screenPos.X, screenPos.Y)
                            text.Visible = true
                        end
                    end
                end
            end
        end
    end
end

local function updateHighlightESP(enabled, color, transparency)
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
            if isAlive(player) then
                local highlight = player.Character:FindFirstChild("Highlight")
                if enabled then
                    if not highlight then
                        local newHighlight = Instance.new("Highlight")
                        newHighlight.Parent = player.Character
                        highlight = newHighlight
                    end
                    highlight.FillColor = color
                    highlight.FillTransparency = transparency
                else
                    if highlight then
                        highlight:Destroy()
                    end
                end
            else
                local highlight = player.Character:FindFirstChild("Highlight")
                if highlight then
                    highlight:Destroy()
                end
            end
        end
    end
end

runService.RenderStepped:Connect(updateESP)

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        task.wait(0.5)
        if highlightEspSettings.enabled then
            updateHighlightESP(true, highlightEspSettings.color, highlightEspSettings.transparency)
        end
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    if playerText[player] then
        playerText[player]:Remove()
        playerText[player] = nil
    end
    if highlightEspSettings.enabled then
        updateHighlightESP(true, highlightEspSettings.color, highlightEspSettings.transparency)
    end
end)

Tabs.EspTab:Toggle({
    Title = "Highlight ESP",
    Default = false,
    Callback = function(tog)
        highlightEspSettings.enabled = tog
        updateHighlightESP(tog, highlightEspSettings.color, highlightEspSettings.transparency)
    end
})

Tabs.EspTab:Toggle({
    Title = "Включить Names ESP",
    Default = false,
    Callback = function(enabled)
        espSettings.namesEnabled = enabled
    end
})

Tabs.EspTab:Toggle({
    Title = "Включить Distance ESP",
    Default = false,
    Callback = function(enabled)
        espSettings.distanceEnabled = enabled
    end
})

Tabs.SettingsEspTab:Dropdown({
    Title = "Цвет Highlight ESP",
    Values = { "Green", "Red", "Blue", "Yellow", "Pink", "Purple" },
    Value = "Red",
    Callback = function(option)
        local colors = {
            Green = Color3.fromRGB(0, 255, 0),
            Red = Color3.fromRGB(255, 0, 0),
            Blue = Color3.fromRGB(0, 0, 255),
            Yellow = Color3.fromRGB(255, 255, 0),
            Pink = Color3.fromRGB(239, 14, 216),
            Purple = Color3.fromRGB(180, 14, 240)
        }
        highlightEspSettings.color = colors[option]
        if highlightEspSettings.enabled then
            updateHighlightESP(true, highlightEspSettings.color, highlightEspSettings.transparency)
        end
    end,
})

Tabs.SettingsEspTab:Input({
    Title = "Прозрачность Highlight ESP",
    Default = 0.5,
    Placeholder = "Введите прозрачность",
    Callback = function(input)
        local value = tonumber(input)
        if typeof(value) == "number" then
            highlightEspSettings.transparency = math.clamp(value, 0, 1)
            if highlightEspSettings.enabled then
                updateHighlightESP(true, highlightEspSettings.color, highlightEspSettings.transparency)
            end
        end
    end,
})

Tabs.SettingsEspTab:Dropdown({
    Title = "Цвет Names ESP",
    Values = colorOptions,
    Value = "White",
    Callback = function(option)
        espSettings.namesColor = colorValues[option]
    end,
})

Tabs.SettingsEspTab:Dropdown({
    Title = "Цвет Distance ESP",
    Values = colorOptions,
    Value = "White",
    Callback = function(option)
        espSettings.distanceColor = colorValues[option]
    end,
})

AimbotTab = Window:Tab({ Title = "Аимбот", Icon = "axe", Desc = "Автонаводка на врагов"
    })

local Settings = {
    Enabled = false,
    AimKey = "RightShift",
    AimRadius = 100,
    PredictionFactor = 0.1,
    SmoothingFactor = 0.1,
    TargetPart = "Head",
    OnlyVisible = true,
    TeamCheck = false,
}

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

-- Вкладка "Аимбот"

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local localPlayer = Players.LocalPlayer
local camera = Workspace.CurrentCamera
local isCameraLocked = false
local lockedPlayer = nil
local defaultCameraType = Enum.CameraType.Custom
local lockRadius = 50 -- Значение по умолчанию для радиуса
local cameraRotationSpeed = 0.1 -- Скорость вращения камеры (чем меньше, тем медленнее)

-- Targeting Indicator (BillboardGui)
local targetIndicator = Instance.new("BillboardGui")
targetIndicator.Size = UDim2.new(2, 0, 1, 0)
targetIndicator.AlwaysOnTop = true
targetIndicator.Enabled = false

local arrow = Instance.new("ImageLabel")
arrow.Size = UDim2.new(1, 0, 1, 0)
arrow.BackgroundTransparency = 1
arrow.Image = "rbxassetid://602361387"
arrow.ImageColor3 = Color3.new(1, 1, 0)
arrow.Position = UDim2.new(0.5, 0, -1.5, 0)
arrow.AnchorPoint = Vector2.new(0.5, 0.5)
arrow.Parent = targetIndicator

targetIndicator.Parent = Workspace

local function getNearestPlayer(radius)
    local nearestPlayer = nil
    local minDistanceSquared = math.huge

    if not localPlayer or not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end

    local localRootPart = localPlayer.Character.HumanoidRootPart.Position

    for _, player in Players:GetPlayers() do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local otherRootPart = player.Character.HumanoidRootPart.Position
            local distanceSquared = (localRootPart - otherRootPart).Magnitude^2

            if distanceSquared <= radius^2 and distanceSquared < minDistanceSquared then
                minDistanceSquared = distanceSquared
                nearestPlayer = player
            end
        end
    end
    return nearestPlayer
end

local function getPlayerByName(playerName)
    if playerName == "None" then
        return nil
    end
    for _, player in Players:GetPlayers() do
        if player.Name == playerName and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            return player
        end
    end
    return nil
end

local function updateCameraLookAt()
    if isCameraLocked and localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetPosition = nil
        if lockedPlayer and lockedPlayer.Character and lockedPlayer.Character:FindFirstChild("HumanoidRootPart") then
            targetPosition = lockedPlayer.Character.HumanoidRootPart.Position
        elseif isCameraLocked then -- Попытка найти ближайшего, если игрок не выбран вручную
            local nearest = getNearestPlayer(lockRadius)
            if nearest then
                lockedPlayer = nearest
                targetPosition = lockedPlayer.Character.HumanoidRootPart.Position
            end
        end

        if targetPosition then
            camera.CameraType = Enum.CameraType.Scriptable
            local localRootPosition = localPlayer.Character.HumanoidRootPart.Position
            local desiredLookAt = targetPosition
            local cameraOffset = Vector3.new(0, 2, 5)
            local desiredCameraPosition = localRootPosition + (desiredLookAt - localRootPosition).Unit * cameraOffset.Z + Vector3.new(0, cameraOffset.Y, 0)

            local currentCF = camera.CFrame
            local desiredCF = CFrame.lookAt(desiredCameraPosition, desiredLookAt)

            camera.CFrame = currentCF:Lerp(desiredCF, cameraRotationSpeed)

            targetIndicator.Adornee = lockedPlayer.Character.HumanoidRootPart
            targetIndicator.Enabled = true
        else
            camera.CameraType = defaultCameraType
            lockedPlayer = nil
            targetIndicator.Enabled = false
        end
    else
        camera.CameraType = defaultCameraType
        lockedPlayer = nil
        targetIndicator.Enabled = false
    end
end

local function getUpdatedPlayerList()
    local dropdownValues = {"None"}
    for _, player in Players:GetPlayers() do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            table.insert(dropdownValues, player.Name)
        end
    end
    table.sort(dropdownValues)
    return dropdownValues
end

local dropdownElement

Tabs.AimbotTab:Toggle({
    Title = "Сфокусировать камеру на игрока",
    Default = false,
    Callback = function(Value)
        isCameraLocked = Value
        if Value == true then
            camera.CameraType = Enum.CameraType.Scriptable
            RunService.RenderStepped:Connect(updateCameraLookAt)
            if dropdownElement then
                dropdownElement:Set("Values", getUpdatedPlayerList())
            end
            if dropdownElement and dropdownElement.Value ~= "None" then
                lockedPlayer = getPlayerByName(dropdownElement.Value)
            elseif Value == true and dropdownElement and dropdownElement.Value == "None" then
                -- При включении и отсутствии выбранного игрока, пытаемся найти ближайшего
                lockedPlayer = getNearestPlayer(lockRadius)
            end
        else
            camera.CameraType = defaultCameraType
            lockedPlayer = nil
            targetIndicator.Enabled = false
            for _, connection in pairs(RunService:GetConnections("RenderStepped")) do
                if connection.Function == updateCameraLookAt then
                    connection:Disconnect()
                    break
                end
            end
        end
    end
})

dropdownElement = Tabs.AimbotTab:Dropdown({
    Title = "Сменить фокус на другого игрока",
    Values = getUpdatedPlayerList(),
    Value = "None",
    Callback = function(selectedPlayerName)
        lockedPlayer = getPlayerByName(selectedPlayerName)
        if lockedPlayer and isCameraLocked then
            print("Camera locked to:", selectedPlayerName)
        elseif isCameraLocked then
            print("Camera lock disabled.")
        end
    end
})

Tabs.AimbotTab:Slider({
    Title = "Радиус фокуса",
    Value = {min = 10, max = 200, Default = 100},
    Callback = function(Value)
        lockRadius = Value
        print("Lock radius changed to:", lockRadius)
        if isCameraLocked and not lockedPlayer then -- Если ручной выбор не активен, пытаемся обновить цель
            lockedPlayer = getNearestPlayer(lockRadius)
        end
    end
})

Tabs.AimbotTab:Button({
    Title = "Обновить список игроков",
    Callback = function()
        if dropdownElement then
            dropdownElement:Set("Values", getUpdatedPlayerList())
        end
    end
})

Players.PlayerAdded:Connect(function(player)
    if isCameraLocked and dropdownElement then
        task.wait(0.5)
        dropdownElement:Set("Values", getUpdatedPlayerList())
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if isCameraLocked and dropdownElement then
        dropdownElement:Set("Values", getUpdatedPlayerList())
        if lockedPlayer == player then
            lockedPlayer = nil
            camera.CameraType = defaultCameraType
            targetIndicator.Enabled = false
        end
    end
end)

local Tab = Window:Tab({Title = "Настройки", Icon = "cog"})

Tab:Toggle({
    Title = "Ноклип",
    Callback = function(state)
        Settings.Noclip.Enabled = state
        ToggleNoclip(state)
    end
})

Tab:Toggle({
    Title = "Хитбоксы",
    Callback = function(state)
        Settings.Hitbox.Enabled = state
        if state then
            RunService.Heartbeat:Connect(UpdateHitboxes)
        else
            for _, box in pairs(Settings.Hitbox.Adornments) do
                box:Destroy()
            end
            Settings.Hitbox.Adornments = {}
        end
    end
})

Tab:Slider({
    Title = "Размер хитбокса",
    Value = {Min=1, Max=10, Default=5},
    Callback = function(val)
        Settings.Hitbox.Size = val
        UpdateHitboxes()
    end
})

Tab:Colorpicker({
    Title = "Цвет хитбокса",
    Default = Color3.new(1,0,0),
    Callback = function(col)
        Settings.Hitbox.Color = col
        UpdateHitboxes()
    end
})

Tab:Toggle({
    Title = "Анти-AFK",
    Callback = function(state)
        Settings.AntiAFK.Enabled = state
        ToggleAntiAFK(state)
    end
})

-- Очистка
game:BindToClose(function()
    ToggleNoclip(false)
    ToggleAntiAFK(false)
    for _,v in pairs(Settings.Hitbox.Adornments) do v:Destroy() end
end)

Window:Open()